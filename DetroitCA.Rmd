---
title: "Detroit Metro Land Cover Change Modeled by Cellular Automata"
author: "K. Arthur Endsley"
date: 'Sunday, November 23, 2014'
output:
  html_document:
    toc: yes
  pdf_document:
    toc: yes
---

```{r preamble, warning=FALSE, message=FALSE, results=FALSE}
library(sp, raster)
library(rgdal)
library(plyr, reshape2)
library(bnlearn)

setwd('/usr/local/dev/rdetroit/')
options(stringsAsFactors=FALSE)
```

# Methodology

1. Aggregate and stack predictor variables as rasters.
2. In a CA simulation...
  - For each pixel, pick one of the land cover values based on its probability

# Preparation

## Land Cover Data

We'll try aggregating the data to 90 meters to see if that gives us a feasible grid with which to work.

```{r}
file.loc <- '/home/arthur/Workspace/TermProject/'

require(raster)
rast2001 <- raster::raster(paste0(file.loc, 'nlcd2001_nad83.tif'))
rast2006 <- raster::raster(paste0(file.loc, 'nlcd2006_nad83.tif'))
reclass.matrix <- matrix(c(c(0,10,0), c(10,11,NA), c(12,20,0),
                           c(20,23,1), c(23,24,2), c(24,99,0)),
                         byrow=TRUE, ncol=3)
dev2001 <- raster::reclassify(rast2001, reclass.matrix, right=TRUE) # Intervals closed on right
dev2006 <- raster::reclassify(rast2006, reclass.matrix, right=TRUE)
```

```{r}
plot(dev2001); title('2001 Development Intensity at 30 meters')
```

```{r}
counties <- readOGR(paste0(file.loc, 'ancillary/co26_d00_select_nad83.shp'),
                    'co26_d00_select_nad83')
counties <- spTransform(counties, crs(dev2001))

plot(counties, col='#EEEEEE')
plot(dev2006 - dev2001, breaks=c(-2, -1, 0, 2), add=TRUE,
     col=c('#77DD00', '#FFFFFF00', '#113355'))
title('Change in Metro Detroit Development, 2001-2006')
```

We'll first aggregate the land cover data to 300 meters.

```{r}
dev2001 <- aggregate(dev2001, fact=10, fun=modal)
dev2006 <- aggregate(dev2006, fact=10, fun=modal)
save(dev2001, dev2006, file='rda/caAggregates.rda')
```

```{r}
plot(dev2001); title('2001 Development Intensity at 300 meters')
```

## Landscape and Census Data

We'll grab the other spatial data we created when training the Bayesian network.

```{r}
file.loc <- '/home/arthur/Workspace/TermProject/'
load(file='rda/spatialMeasures.rda')
load(file='rda/caAggregates.rda') # Replace dev2001 and dev2006 with aggregated

# Recreation and outdoor areas
rec.area.dist <- raster::raster(paste0(file.loc,
                                       'ancillary/rec+outdoor_nad83_prox_cut.tiff'))
rec.area.dist <- resample(rec.area.dist, dev2001)
```

## Rasterizing

```{r}
vars <- c('married.hholds', 'med.hhold.income', 'pop.density', 'male.pop')
layers <- as.list(1:length(vars))
names(layers) <- vars
layers$old <- as.factor(dev2001)
layers$rec.area.proximity <- rec.area.dist

for (var in vars) {
  layers[var] <- rasterize(attr2006, dev2006, var)
}

save(layers, file='rda/layers.rda')
load(file='rda/layers.rda')
```

## Masking and Discretizing

First, we want to mask out the pixels outside of the census tracts.

```{r}
layers$old <- mask(dev2001, layers$pop.density, maskvalue=NA)
layers$rec.area.proximity <- mask(layers$rec.area.proximity,
                                  layers$pop.density, maskvalue=NA)
```

Next, we must discretize all the census and landscape layers.

```{r}
load(file='rda/graphs.rda')

# Create a reclass matrix from the levels
vars <- c('rec.area.proximity', 'married.hholds', 'med.hhold.income', 'pop.density', 'male.pop')
for (var in vars) {
  # Split apart e.g. "(20.1,190]"
  reclass.matrix <- sapply(levels(training.discrete[,var]),
                           function (s) as.numeric(unlist(strsplit(gsub('\\[|\\]|\\(|\\)',
                                                                        '', s), ','))))
  reclass.matrix[1] <- 0
  layers[var] <- raster::reclassify(get(var, layers),
                                    cbind(reclass.matrix, c(0, 1)),
                                    right=TRUE) # Intervals closed on right
}
```

## Stacking

```{r}
layers <- stack(layers)

save(layers, layer.levels, file='rda/layerStack.rda')
load(file='rda/layerStack.rda')

# Clean-up
remove(var, vars, rec.area.dist, roads.dist, reclass.matrix)
```

We can see from the min and max values in the following output that all of our layers have been discretized.

```{r}
layers
```

# Examining the Network

```{r}
# TODO An improvement would be to have the levels of the layers be in [0, 1, 2, ...]
layer.levels <- list(rec.area.proximity=levels(training.discrete$rec.area.proximity),
                     married.hholds=levels(training.discrete$married.hholds),
                     med.hhold.income=levels(training.discrete$med.hhold.income),
                     pop.density=levels(training.discrete$pop.density),
                     male.pop=levels(training.discrete$male.pop))

# A function to update the posterior probability distribution with evidence
updateNetwork <- function (jtree, states) {
  # Do not do anything if the input data are all NA
  if (all(is.na(states))) {
    return(jtree)
  }
  
  evidence <- transform(states,
                     married.hholds=layer.levels$married.hholds[married.hholds + 1],
                     med.hhold.income=layer.levels$med.hhold.income[med.hhold.income + 1],
                     pop.density=layer.levels$pop.density[pop.density + 1],
                     male.pop=layer.levels$male.pop[male.pop + 1],
                     rec.area.proximity=layer.levels$rec.area.proximity[rec.area.proximity + 1],
                     old=as.character(old))
  
  for (i in seq(1, dim(evidence)[1])) {
    jtree <- setEvidence(jtree, nodes=names(evidence), nslist=mapply(list, evidence[i,]))
  }
  
  jtree
}

# A function to choose outcomes, one at a time, with the same probability as the given posterior distribution
chooseOutcome <- function (posterior) {
  post <- as.numeric(posterior)
  prob <- rep(0, length(post))
  for (i in seq(length(post) - 1, 1, by=-1)) {
    j <- length(post) - i
    prob <- prob + c(rep(0, j), post[(j-1):(length(post)-j)])
  }
  
  r <- runif(1)
  for (i in seq(0, length(prob) - 2)) {
    if (r < prob[i + 2]) {
      return(i)
    }
  }
  
  (length(prob) - 1)
}
```

Does our function reproduce classes with the same proportion as in the probability distribution?

```{r}
foo <- as.numeric(querygrain(prior, nodes='new')$new)
bar <- c()
for (i in seq(1, 10000)) { bar <- c(bar, chooseOutcome(foo)) }
unique(bar)
c(length(bar[bar==0])/length(bar), length(bar[bar==1])/length(bar), length(bar[bar==2])/length(bar))
foo
```

```{r message=FALSE, warning=FALSE}
load(file='rda/graphs.rda')

require(gRain)

# We use the junction tree algorithm to create an independence network that we can query
prior <- compile(as.grain(fit.expert))

# Get the prior probabilities for new land cover
querygrain(prior, nodes='new')$new

# Update the posterior
posterior <- updateNetwork(prior, getValues(layers, 1, 1))

# Get the posterior probabilities for new land cover
querygrain(posterior, nodes='new')$new
```

# Simulation

```{r message=FALSE, warning=FALSE}
load(file='rda/graphs.rda')
load(file='rda/layerStack.rda')

require(gRain)

# We use the junction tree algorithm to create an independence network that we can query
prior <- compile(as.grain(fit.expert))

# Both approaches, calc() and stackApply(), take the same amount of time
# output <- raster::calc(layers, function (states) {
#   apply(states, 1, function (r) {
#     chooseOutcome(querygrain(updateNetwork(prior, as.data.frame(t(r))), nodes='new')$new)
#   })
# }, forcefun=TRUE)

output <- stackApply(layers, rep(1, length(names(layers))), function (r, ...) {
  chooseOutcome(querygrain(updateNetwork(prior, as.data.frame(t(r))), nodes='new')$new)
})
```

```{r}
load(file='rda/caAggregates.rda')
dev2006 <- mask(dev2006, layers$pop.density, maskvalue=NA)
cols <- c('#FFFFFF', '#AACCEE', '#113355')

plot(dev2006, axes=FALSE, box=FALSE, col=cols, legend=FALSE)
legend('bottomright', legend=c('High Development', 'Low Development', 'Undeveloped'),
       fill=rev(cols), bty="n", title='Legend', cex=1.3)
plot(counties, col='#EEEEEE00', lwd=1, add=TRUE)
title('2006 Observed Land Cover from NLCD')
```

```{r}
output <- mask(output, layers$pop.density, maskvalue=NA)
cols <- c('#FFFFFF', '#AACCEE', '#113355')

plot(output, axes=FALSE, box=FALSE, col=cols, legend=FALSE)
legend('bottomright', legend=c('High Development', 'Low Development', 'Undeveloped'),
       fill=rev(cols), bty="n", title='Legend', cex=1.3)
plot(counties, col='#EEEEEE00', lwd=1, add=TRUE)
title('2006 Simulation from Expert Graph with 2006 Census Data')
```

```{r}
require(RColorBrewer)
cols <- brewer.pal(3, 'RdBu')
cols[2] <- '#000000'
plot(dev2006 - output, axes=FALSE, box=FALSE, col=c(cols[1], cols, cols[3]),
     legend=FALSE)
legend('bottomright', legend=c('Commission', 'Agreement', 'Ommission'),
       fill=rev(cols), bty="n", title='Legend', cex=1.3)
plot(counties, col='#EEEEEE00', lwd=1, add=TRUE)
title('2006 Expert Graph Simulation Subtracted from Observed Land Cover')
```

